<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 11 - Wiener Process Simulation</title>

    <style>
        /* CSS Styling - Consistent with HW10 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fc;
            color: #222;
            margin: 0;
            line-height: 1.6;
        }

        .header {
            background-color: #2c2c2c;
            color: white;
            padding: 80px 0;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 0.3em;
        }

        .header h2 {
            font-weight: 400;
            font-size: 1.3em;
            color: #ddd;
        }

        .content {
            max-width: 900px;
            margin: 40px auto;
            padding: 0 25px;
        }

        h3 {
            border-left: 5px solid #2b4d9a;
            padding-left: 10px;
            color: #1b3d8a;
            margin-top: 40px;
        }

        .math-block {
            text-align: center;
            background-color: #f6f7fc;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            overflow-x: auto;
            font-size: 1.1em;
        }

        .interactive-section {
            background-color: #eef4ff;
            padding: 25px;
            border-radius: 8px;
            margin-top: 30px;
            border: 2px solid #d0e0ff;
        }

        .interactive-section label {
            font-weight: 600;
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            color: #1b3d8a;
        }

        .interactive-section input[type="number"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 150px;
            margin-right: 20px;
        }

        button {
            background-color: #2b4d9a;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 700;
            margin-top: 20px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #1b3d8a;
        }

        .graph-container {
            margin-top: 25px;
            padding: 10px;
            text-align: center;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 6px;
        }

        canvas {
            border: 1px solid #e0e0e0;
            background-color: #fcfcff;
            max-width: 100%;
            cursor: crosshair;
        }

        footer {
            text-align: center;
            font-size: 0.9em;
            color: #555;
            margin-top: 50px;
            padding: 15px 0 30px 0;
            border-top: 1px solid #ccc;
        }

        /* General Link Style (Blue) */
        a {
            color: #1b3d8a;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Ensure 'Back Home' link is definitively black */
        .back-home {
            color: #000 !important;
            text-decoration: none;
            display: inline-block;
            margin-top: 30px;
        }
    </style>

    <script>
        MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }, svg: { fontCache: 'global' } };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <script>
        // --- Simulation Core: Standard Normal Generator ---
        // Using Central Limit Theorem (Sum of 12 Uniforms) approximation
        // This avoids complex transforms like Box-Muller if not explicitly required.
        function getStandardNormal() {
            let sum = 0;
            for (let i = 0; i < 12; i++) {
                sum += Math.random();
            }
            return sum - 6; // Expectation of sum is 6, Variance is 1. Result is approx N(0,1)
        }

        // Helper: Draw Axes with dynamic values
        function drawAxes(ctx, width, height, xMin, xMax, yMin, yMax, padding) {
            ctx.strokeStyle = '#666'; ctx.fillStyle = '#444'; ctx.lineWidth = 1; ctx.font = '10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            const plotW = width - 2 * padding; const plotH = height - 2 * padding; const startX = padding; const startY = padding;

            // Draw X and Y Axes lines
            ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX, startY + plotH); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(startX, startY + plotH); ctx.lineTo(startX + plotW, startY + plotH); ctx.stroke();

            // Y Ticks
            const numYTicks = 6; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
            for (let i = 0; i <= numYTicks; i++) {
                const ratio = i / numYTicks; const yVal = yMin + ratio * (yMax - yMin); const yPos = startY + plotH - (ratio * plotH);
                ctx.beginPath(); ctx.moveTo(startX, yPos); ctx.lineTo(startX - 5, yPos); ctx.stroke();
                ctx.fillText(yVal.toFixed(2), startX - 8, yPos);
            }
            // X Ticks
            const numXTicks = 5; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            for (let i = 0; i <= numXTicks; i++) {
                const ratio = i / numXTicks; const xVal = xMin + ratio * (xMax - xMin); const xPos = startX + ratio * plotW;
                ctx.beginPath(); ctx.moveTo(xPos, startY + plotH); ctx.lineTo(xPos, startY + plotH + 5); ctx.stroke();
                ctx.fillText(xVal.toFixed(1), xPos, startY + plotH + 8);
            }
        }

        // 1. Draw Multiple Wiener Paths (Euler-Maruyama Simulation)
        function drawWienerEnsemble(ctx, width, height, steps, sigma, time, numPathsToDraw) {
            const padding = 50;
            ctx.clearRect(0, 0, width, height);

            const finalStdDev = sigma * Math.sqrt(time);
            const yMaxAbs = Math.max(0.5, 3.5 * finalStdDev);
            const yMin = -yMaxAbs; const yMax = yMaxAbs;
            const xMax = time;

            drawAxes(ctx, width, height, 0, xMax, yMin, yMax, padding);

            const dt = time / steps;
            const plotW = width - 2 * padding; const plotH = height - 2 * padding;
            const scaleX = plotW / xMax; const scaleY = plotH / (yMax - yMin);
            const originX = padding; const originY = padding + plotH - ((0 - yMin) * scaleY);

            ctx.lineWidth = 1;
            for (let p = 0; p < numPathsToDraw; p++) {
                let currentVal = 0;
                ctx.beginPath();
                ctx.strokeStyle = `rgba(31, 119, 180, 0.4)`;
                ctx.moveTo(originX, originY);
                for (let i = 1; i <= steps; i++) {
                    // *** EULER-MARUYAMA STEP ***
                    // dW = sqrt(dt) * Z
                    // B(t+dt) = B(t) + sigma * dW
                    const dW = Math.sqrt(dt) * getStandardNormal();
                    currentVal += sigma * dW;

                    const x = originX + (i * dt) * scaleX;
                    const y = originY - currentVal * scaleY;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }

        // 2. Draw Histogram vs Gaussian Curve
        function drawHistogram(ctx, width, height, steps, sigma, time, numSims) {
            const padding = 50;
            ctx.clearRect(0, 0, width, height);

            const finalValues = [];
            const dt = time / steps;

            for (let i = 0; i < numSims; i++) {
                let val = 0;
                for (let s = 0; s < steps; s++) {
                    // Euler-Maruyama Accumulation
                    val += sigma * Math.sqrt(dt) * getStandardNormal();
                }
                finalValues.push(val);
            }

            const finalStdDev = sigma * Math.sqrt(time);
            const rangeLimit = Math.max(Math.max(...finalValues.map(Math.abs)), 3.5 * finalStdDev);
            const numBins = 50;
            const binWidth = (2 * rangeLimit) / numBins;
            const bins = new Array(numBins).fill(0);

            finalValues.forEach(v => {
                let binIdx = Math.floor((v + rangeLimit) / binWidth);
                if (binIdx >= 0 && binIdx < numBins) bins[binIdx]++;
            });

            const maxCount = Math.max(...bins);
            drawAxes(ctx, width, height, -rangeLimit, rangeLimit, 0, maxCount * 1.1, padding);

            const plotW = width - 2 * padding; const plotH = height - 2 * padding;
            const startX = padding; const baselineY = height - padding;
            const barPixelWidth = plotW / numBins;

            ctx.fillStyle = 'rgba(111, 163, 214, 0.7)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
            for (let i = 0; i < numBins; i++) {
                const barHeight = (bins[i] / (maxCount * 1.1)) * plotH;
                ctx.fillRect(startX + i * barPixelWidth, baselineY - barHeight, barPixelWidth, barHeight);
                ctx.strokeRect(startX + i * barPixelWidth, baselineY - barHeight, barPixelWidth, barHeight);
            }

            // Draw Theoretical Gaussian Curve
            ctx.beginPath(); ctx.strokeStyle = '#d62728'; ctx.lineWidth = 2.5;
            for (let px = 0; px <= plotW; px += 2) {
                const pct = px / plotW;
                const value = -rangeLimit + pct * (2 * rangeLimit);
                const pdf = (1 / (finalStdDev * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow(value / finalStdDev, 2));
                const countY = pdf * binWidth * numSims;
                const plotY = baselineY - (countY / (maxCount * 1.1)) * plotH;

                if (px === 0) ctx.moveTo(startX + px, plotY); else ctx.lineTo(startX + px, plotY);
            }
            ctx.stroke();
        }

        function runAnalysis() {
            const steps = parseInt(document.getElementById('steps').value);
            const sigma = parseFloat(document.getElementById('sigma').value);
            const time = parseFloat(document.getElementById('time').value);
            const numSims = 2000;
            const numPaths = 50;

            if (steps <= 0 || sigma <= 0 || time <= 0) return;

            const pathCanvas = document.getElementById('pathCanvas');
            drawWienerEnsemble(pathCanvas.getContext('2d'), pathCanvas.width, pathCanvas.height, steps, sigma, time, numPaths);

            const histCanvas = document.getElementById('histCanvas');
            drawHistogram(histCanvas.getContext('2d'), histCanvas.width, histCanvas.height, steps, sigma, time, numSims);

            // Update Theory Text Formula
            const theoryVar = sigma * sigma * time;
            const theoryText = document.getElementById('theoryText');
            theoryText.innerHTML = `$$ \\text{Theoretical Variance } \\sigma^2_{total} = \\sigma^2 \\cdot T \\approx ${theoryVar.toFixed(4)} $$`;
            if (window.MathJax) MathJax.typesetPromise([theoryText]);
        }
        window.onload = runAnalysis;
    </script>
</head>

<body>
    <div class="header">
        <h1>Homework 11</h1>
        <h2>Wiener Process Simulation (Euler–Maruyama Method)</h2>
    </div>

    <div class="content">

        <h3>Simulation Objective</h3>
        <p>
            The goal of this assignment is to simulate a <b>Wiener Process</b> (Brownian Motion) by solving the
            Stochastic Differential Equation (SDE) using the <b>Euler–Maruyama method</b>.
            This focuses on the numerical reconstruction of the continuous path $B_t$ given its stochastic differential
            properties.
        </p>

        <h4>1. The Stochastic Differential Equation (SDE)</h4>
        <p>
            Standard Brownian Motion, or the Wiener Process $W_t$, is characterized by independent, normally distributed
            increments.
            The generalized process $B_t$ with volatility $\sigma$ is defined by the SDE:
        </p>
        <div class="math-block">
            $$ dB_t = \sigma \, dW_t, \quad B_0 = 0 $$
        </div>

        <h4>2. The Euler–Maruyama Discretization</h4>
        <p>
            To simulate this on a computer, we discretize the continuous time interval $[0, T]$ into $N$ small steps of
            size $\Delta t = T/N$.
            The <b>Euler–Maruyama approximation</b> updates the position iteratively:
        </p>
        <div class="math-block">
            $$ B_{t + \Delta t} = B_t + \sigma \cdot \Delta W_t $$
            $$ B_{t + \Delta t} = B_t + \sigma \sqrt{\Delta t} \, Z $$
        </div>
        <p>
            Here, $Z$ is a standard normal random variable ($Z \sim \mathcal{N}(0, 1)$).
            Crucially, the scaling term $\sqrt{\Delta t}$ reflects the fractal nature of Brownian motion: variance
            scales linearly with time, so standard deviation scales with the square root of time.
        </p>

        <hr>

        <div class="interactive-section">
            <h4>Simulation Parameters</h4>

            <label>Total Time ($T$): <input type="number" id="time" value="1.0" step="0.1"></label>
            <label>Number of Steps ($N$): <input type="number" id="steps" value="300" step="50"></label>
            <label>Volatility ($\sigma$): <input type="number" id="sigma" value="1.0" step="0.1"></label>

            <button onclick="runAnalysis()">Run Simulation</button>

            <div id="theoryText" style="margin-top:20px; font-weight:bold; color:#333; text-align:center;"></div>

            <div class="graph-container">
                <p><b>Ensemble of Wiener Paths (50 Realizations)</b><br>
                    <small>Visualizing the stochastic spread over time</small>


                    [Image of Normal Distribution]

                </p>
                <canvas id="pathCanvas" width="750" height="400"></canvas>
            </div>

            <div class="graph-container">
                <p><b>Distribution of Final Positions $B(T)$</b><br>
                    <small>Empirical Histogram vs Theoretical Normal PDF</small>


                    [Image of Normal Distribution]

                </p>
                <canvas id="histCanvas" width="750" height="400"></canvas>
            </div>
        </div>

        <h3>Conclusion</h3>
        <p>
            This exercise demonstrates the effectiveness of the <b>Euler–Maruyama method</b> for SDE simulation.
            By correctly scaling the stochastic noise by $\sqrt{\Delta t}$, the discrete steps accumulate to form a
            continuous Wiener process.
            The histogram confirms that the final positions are normally distributed with variance $\sigma^2 T$,
            matching the theoretical definition of Brownian motion.
        </p>

        <h3>Sources</h3>
        <ul>
            <li><a href="https://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method" target="_blank">Wikipedia –
                    Euler–Maruyama Method</a></li>
            <li><a href="https://en.wikipedia.org/wiki/Wiener_process" target="_blank">Wikipedia – Wiener Process
                    (Brownian Motion)</a></li>
            <li><a href="https://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank">Wikipedia –
                    Central Limit Theorem (Normal approximation)</a></li>
        </ul>

        <a href="../../index.html" class="back-home">← Back Home</a>
    </div>

    <footer>
        © 2025 - Domenico Sarno | 3rd Dec - Homework 11
    </footer>
</body>

</html>