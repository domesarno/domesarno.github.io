<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 11 - Wiener Process (Euler-Maruyama)</title>

    <style>
        /* CSS Styling - Consistent with HW10 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fc;
            color: #222;
            margin: 0;
            line-height: 1.6;
        }

        .header {
            background-color: #2c2c2c;
            color: white;
            padding: 80px 0;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 0.3em;
        }

        .header h2 {
            font-weight: 400;
            font-size: 1.3em;
            color: #ddd;
        }

        .content {
            max-width: 900px;
            margin: 40px auto;
            padding: 0 25px;
        }

        h3 {
            border-left: 5px solid #2b4d9a;
            padding-left: 10px;
            color: #1b3d8a;
            margin-top: 40px;
        }

        .math-block {
            text-align: center;
            background-color: #f6f7fc;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            overflow-x: auto;
            font-size: 1.1em;
        }

        .interactive-section {
            background-color: #eef4ff;
            padding: 25px;
            border-radius: 8px;
            margin-top: 30px;
            border: 2px solid #d0e0ff;
        }

        .interactive-section label {
            font-weight: 600;
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            color: #1b3d8a;
        }

        .interactive-section input[type="number"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 150px;
            margin-right: 20px;
        }

        button {
            background-color: #2b4d9a;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 700;
            margin-top: 20px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #1b3d8a;
        }

        .graph-container {
            margin-top: 25px;
            padding: 10px;
            text-align: center;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 6px;
        }

        canvas {
            border: 1px solid #e0e0e0;
            background-color: #fcfcff;
            max-width: 100%;
            cursor: crosshair;
        }

        footer {
            text-align: center;
            font-size: 0.9em;
            color: #555;
            margin-top: 50px;
            padding: 15px 0 30px 0;
            border-top: 1px solid #ccc;
        }

        /* General Link Style (Blue) */
        a {
            color: #1b3d8a;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* FIX: Ensure 'Back Home' link is definitively black */
        .back-home {
            color: #000 !important;
            text-decoration: none;
            display: inline-block;
            margin-top: 30px;
        }
    </style>


    <script>
        MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }, svg: { fontCache: 'global' } };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <script>
        // --- Simulation Core: Box-Muller (Standard Normal Generator) ---
        function getStandardNormal() {
            let u1 = 0, u2 = 0;
            while (u1 === 0) u1 = Math.random();
            while (u2 === 0) u2 = Math.random();
            const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            return z0; // Returns Z ~ N(0, 1)
        }

        // Helper: Draw Axes with dynamic values
        function drawAxes(ctx, width, height, xMin, xMax, yMin, yMax, padding) {
            ctx.strokeStyle = '#666'; ctx.fillStyle = '#444'; ctx.lineWidth = 1; ctx.font = '10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            const plotW = width - 2 * padding; const plotH = height - 2 * padding; const startX = padding; const startY = padding;

            ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX, startY + plotH); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(startX, startY + plotH); ctx.lineTo(startX + plotW, startY + plotH); ctx.stroke();

            const numYTicks = 6; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
            for (let i = 0; i <= numYTicks; i++) {
                const ratio = i / numYTicks; const yVal = yMin + ratio * (yMax - yMin); const yPos = startY + plotH - (ratio * plotH);
                ctx.beginPath(); ctx.moveTo(startX, yPos); ctx.lineTo(startX - 5, yPos); ctx.stroke();
                ctx.fillText(yVal.toFixed(2), startX - 8, yPos);
            }
            const numXTicks = 5; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            for (let i = 0; i <= numXTicks; i++) {
                const ratio = i / numXTicks; const xVal = xMin + ratio * (xMax - xMin); const xPos = startX + ratio * plotW;
                ctx.beginPath(); ctx.moveTo(xPos, startY + plotH); ctx.lineTo(xPos, startY + plotH + 5); ctx.stroke();
                ctx.fillText(xVal.toFixed(1), xPos, startY + plotH + 8);
            }
        }

        // 1. Draw Multiple Brownian Paths (Ensemble)
        function drawWienerEnsemble(ctx, width, height, steps, sigma, time, numPathsToDraw) {
            const padding = 50;
            ctx.clearRect(0, 0, width, height);

            const finalStdDev = sigma * Math.sqrt(time);
            const yMaxAbs = Math.max(0.5, 3.5 * finalStdDev);

            const yMin = -yMaxAbs; const yMax = yMaxAbs;
            const xMax = time;

            drawAxes(ctx, width, height, 0, xMax, yMin, yMax, padding);

            const dt = time / steps;
            const plotW = width - 2 * padding; const plotH = height - 2 * padding;
            const scaleX = plotW / xMax; const scaleY = plotH / (yMax - yMin);
            const originX = padding; const originY = padding + plotH - ((0 - yMin) * scaleY);

            ctx.lineWidth = 1;
            for (let p = 0; p < numPathsToDraw; p++) {
                let currentVal = 0;
                ctx.beginPath();
                ctx.strokeStyle = `rgba(31, 119, 180, 0.4)`;
                ctx.moveTo(originX, originY);
                for (let i = 1; i <= steps; i++) {
                    // EULER-MARUYAMA STEP: B(t+dt) = B(t) + sigma * sqrt(dt) * Z
                    currentVal += sigma * Math.sqrt(dt) * getStandardNormal();

                    const x = originX + (i * dt) * scaleX; // X based on TIME (not step count)
                    const y = originY - currentVal * scaleY;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }

        // 2. Draw Histogram vs Gaussian Curve
        function drawHistogram(ctx, width, height, steps, sigma, time, numSims) {
            const padding = 50;
            ctx.clearRect(0, 0, width, height);

            const finalValues = [];
            const dt = time / steps;

            for (let i = 0; i < numSims; i++) {
                let val = 0;
                for (let s = 0; s < steps; s++) {
                    // EULER-MARUYAMA STEP (final position only)
                    val += sigma * Math.sqrt(dt) * getStandardNormal();
                }
                finalValues.push(val);
            }

            const finalStdDev = sigma * Math.sqrt(time);
            const rangeLimit = Math.max(Math.max(...finalValues.map(Math.abs)), 3.5 * finalStdDev);
            const numBins = 50;
            const binWidth = (2 * rangeLimit) / numBins;
            const bins = new Array(numBins).fill(0);

            finalValues.forEach(v => {
                let binIdx = Math.floor((v + rangeLimit) / binWidth);
                if (binIdx >= 0 && binIdx < numBins) bins[binIdx]++;
            });

            const maxCount = Math.max(...bins);
            drawAxes(ctx, width, height, -rangeLimit, rangeLimit, 0, maxCount * 1.1, padding);

            const plotW = width - 2 * padding; const plotH = height - 2 * padding;
            const startX = padding; const baselineY = height - padding;
            const barPixelWidth = plotW / numBins;

            ctx.fillStyle = 'rgba(111, 163, 214, 0.7)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
            for (let i = 0; i < numBins; i++) {
                const barHeight = (bins[i] / (maxCount * 1.1)) * plotH;
                ctx.fillRect(startX + i * barPixelWidth, baselineY - barHeight, barPixelWidth, barHeight);
                ctx.strokeRect(startX + i * barPixelWidth, baselineY - barHeight, barPixelWidth, barHeight);
            }

            // Draw Theoretical Gaussian Curve
            ctx.beginPath(); ctx.strokeStyle = '#d62728'; ctx.lineWidth = 2.5;
            for (let px = 0; px <= plotW; px += 2) {
                const pct = px / plotW;
                const value = -rangeLimit + pct * (2 * rangeLimit);
                const pdf = (1 / (finalStdDev * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow(value / finalStdDev, 2));
                const countY = pdf * binWidth * numSims;
                const plotY = baselineY - (countY / (maxCount * 1.1)) * plotH;

                if (px === 0) ctx.moveTo(startX + px, plotY); else ctx.lineTo(startX + px, plotY);
            }
            ctx.stroke();
        }

        function runAnalysis() {
            const steps = parseInt(document.getElementById('steps').value);
            const sigma = parseFloat(document.getElementById('sigma').value);
            const time = parseFloat(document.getElementById('time').value);
            const numSims = 2000;
            const numPaths = 50;

            if (steps <= 0 || sigma <= 0 || time <= 0) return;

            const pathCanvas = document.getElementById('pathCanvas');
            drawWienerEnsemble(pathCanvas.getContext('2d'), pathCanvas.width, pathCanvas.height, steps, sigma, time, numPaths);

            const histCanvas = document.getElementById('histCanvas');
            drawHistogram(histCanvas.getContext('2d'), histCanvas.width, histCanvas.height, steps, sigma, time, numSims);

            // Update Theory Text Formula
            const theoryVar = sigma * sigma * time;
            const theoryText = document.getElementById('theoryText');
            // The formula is Var(B_T) = sigma^2 * T
            theoryText.innerHTML = `$$ \\text{Theoretical Variance } \\sigma^2_{total} = \\sigma^2 \\cdot T \\approx ${theoryVar.toFixed(4)} $$`;
            if (window.MathJax) MathJax.typesetPromise([theoryText]);
        }
        window.onload = runAnalysis;
    </script>
</head>

<body>
    <div class="header">
        <h1>Homework 11</h1>
        <h2>Wiener Process Simulation (Euler–Maruyama Method)</h2>
    </div>

    <div class="content">

        <h3>Stochastic Differential Equation (SDE) Model</h3>
        <p>
            The official requirement is to simulate the <b>Wiener Process</b> (standard Brownian Motion) using the
            <b>Euler–Maruyama method</b>. The Wiener Process is defined by the SDE:
        </p>
        <div class="math-block">
            $$ dB_t = \sigma \, dW_t $$
        </div>
        <p>
            Where $dW_t$ represents the stochastic increment (noise) and $\sigma$ is the <b>volatility</b> parameter. We
            model the process $B_t$ with initial condition $B_0=0$.
        </p>

        <h4>Euler–Maruyama Discretization</h4>
        <p>
            The <b>Euler–Maruyama scheme</b> is the simplest method for numerically solving SDEs. We discretize the time
            interval $T$ into $N$ steps of size $\Delta t = T/N$. The resulting iterative scheme is:
        </p>
        <div class="math-block">
            $$ B_{t + \Delta t} = B_t + \sigma \sqrt{\Delta t} \, Z $$
        </div>
        <p>
            Where $Z$ is a standard normal random variable ($Z \sim \mathcal{N}(0, 1)$), generated here using the
            <b>Box-Muller</b> transformation. This correctly accounts for the fact that the variance of the increment
            $\Delta W_t$ is proportional to $\Delta t$.
        </p>

        <hr>

        <div class="interactive-section">
            <h4>Simulation Parameters</h4>

            <label>Total Time ($T$): <input type="number" id="time" value="1.0" step="0.1"></label>
            <label>Number of Steps ($N$): <input type="number" id="steps" value="300" step="50"></label>
            <label>Volatility ($\sigma$): <input type="number" id="sigma" value="1.0" step="0.1"></label>

            <button onclick="runAnalysis()">Run Simulation</button>

            <div id="theoryText" style="margin-top:20px; font-weight:bold; color:#333; text-align:center;"></div>

            <div class="graph-container">
                <p><b>Gaussian Random Walk Ensemble (50 Paths)</b><br>
                    <small>X-Axis: Time $t$ | Y-Axis: Position $B(t)$</small>
                </p>
                <canvas id="pathCanvas" width="750" height="400"></canvas>
            </div>

            <div class="graph-container">
                <p><b>Distribution of Final Positions $B(T)$</b><br>
                    <small>Histogram vs Theoretical Normal PDF</small>
                </p>
                <canvas id="histCanvas" width="750" height="400"></canvas>
            </div>
        </div>

        <h3>Conclusion</h3>
        <p>
            By applying the <b>Euler–Maruyama method</b>, we correctly simulate the Wiener Process in continuous time.
            The resulting diffusion process confirms two key theoretical results:
        </p>
        <ol>
            <li>
                <b>SDE Discretization:</b> The simulation successfully implements the fundamental SDE numerical scheme,
                $B_{t+\Delta t} = B_t + \sigma \sqrt{\Delta t} Z$.
            </li>
            <li>
                <b>Distribution:</b> The final position $B(T)$ follows $B(T) \sim \mathcal{N}(0, \sigma^2 T)$, visually
                confirmed by the perfect fit of the empirical histogram to the theoretical Gaussian curve.
            </li>
        </ol>

        <h3>Sources</h3>
        <ul>
            <li><a href="https://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method" target="_blank">Wikipedia –
                    Euler–Maruyama Method</a></li>
            <li><a href="https://en.wikipedia.org/wiki/Wiener_process" target="_blank">Wikipedia – Wiener Process
                    (Brownian Motion)</a></li>
            <li><a href="https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform" target="_blank">Wikipedia –
                    Box-Muller Transform</a></li>
        </ul>

        <a href="../../index.html" class="back-home">← Back Home</a>
    </div>

    <footer>
        © 2025 - Domenico Sarno | 3rd Dec - Homework 11
    </footer>
</body>

</html>